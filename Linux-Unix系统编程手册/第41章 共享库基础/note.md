# 对象库

[gcc参数详解](https://www.runoob.com/w3cnote/gcc-parameter-detail.html)

编译器在执行编译工作的时候分为四步：
1. 预处理,生成 .i 的文件[预处理器cpp]
2. 将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]
3. 有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]
4. 连接目标代码, 生成可执行程序 [链接器ld]

构建程序最简单的方式如下
```
$ cc -g -c prog.c mode1.c mod2.c mod3.c
$ cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o
```
> -c 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件 将生成 .o 的 obj 文件  1 2 3 步  
> -o 制定目标名称, 默认的时候, gcc 编译出来的文件是 a.out  4步  
> -g 只是编译器，在编译的时候，产生调试信息。  

如果是一个大型项目，obj文件文件会很多，不好管理，为解决这一问题，将一组目标文件组织成一个被称为对象库的单元。对象库分为两种：
- 静态的
- 共享的

# 静态库

静态库也叫归档文件，unix系统提供的第一种库。有如下好处
- 将一组经常用到的目标文件组织进单个库文件中，这样就可以使用它来构建多个可执行程序并且在构建各个应用程序的时候无需重新编译原来的代码文件
- 链接命令变简单，无需一个个列出目标文件。连接器知道如何搜索静态库并将可执行程序需要的对象抽取出来

## 创建维护静态库
从结果上来看，静态库实际上就是一个保存所有被添加到其中的目标文件的副本的文件。
这个归档文件还记录着每个目标文件的各种特性，包括文件权限、数字用户和组 ID 以及最后
修改时间。根据惯例，静态库的名称的形式为 libname.a。

使用 ar(1)命令能够创建和维护静态库，其通用形式如下所示。
`ar options archive object-file...`
如下创建静态库示例：
```
$ cc -g -c prog.c mode1.c mod2.c mod3.c
$ ar r libdemo.a mod1.o mod2.o mod3.o
```
常用option参数有 r 插入 t 目录表 d 删除等
## 使用静态库
将程序与静态库链接有两种方式
第一种链接命令中指定静态库名称
```
$ cc -g -c prog.c
$ cc -g -o prog prog.o libdemo.a
```
第二种将静态库放在链接器搜索的其中一个标准目录中（如/usr/lib），然后使用-l 选项指定
库名（即库的文件名去除了 lib 前缀和.a 后缀）。
```
$ cc -g -o prog prog.o -Idemo
```
如果不在链接的搜索目录中，可以使用-L选项指定连接器搜索这个额外的目录
```
$ cc -g -o prog prog.o -Lmylibdir -Idemo 
```
虽然一个静态库可以包含很多目标模块，但链接器只会包含那些程序需要的模块。

# 共享库
将程序与静态库链接起来时（或没有使用静态库），得到的`可执行文件`会包含所有`被链接`进程序的`目标文件`的`副本`。
这样当几个不同的可执行程序使用了同样的目标模块时，每个可执行程序会拥有自己的目标模块的副本。这种代码的冗余存在几个缺点。
- 存储同一个目标模块的多个副本会`浪费磁盘空间`，并且所浪费的空间是比较大的。
- 如果几个使用了同一模块的程序在同一时刻运行，那么每个程序会独立地`在虚拟内存中保存一份目标模块的副本`，从而提高系统中虚拟内存的整体使用量。
- 如果需要修改一个静态库中的一个目标模块（可能是因为安全性或需要修正 bug），那么所有使用那个模块的可执行文件都必须要重新进行链接以合并这个变更。这个缺点还会导致系统管理员需要弄清楚哪些应用程序链接了这个库。

共享库就是设计用来解决这些缺点的。共享库的关键思想是目标模块的单个副本由所有
需要这些模块的程序共享。目标模块不会被复制到链接过的可执行文件中，相反，当第一个
需要共享库中的模块的程序启动时，库的单个副本就会在运行时被加载进内存。当后面使用
同一共享库的其他程序启动时，它们会使用已经被加载进内存的库的副本。使用共享库意味
着可执行程序需要的磁盘空间和虚拟内存（在运行的时候）更少了。

共享库还具备下列优势。
- 由于整个程序的大小变得更小了，因此在一些情况下，程序可以完全被加载进内存中，从而能够更快地启动程序。这一点只有在大型共享库正在被其他程序使用的情况下才成立。第一个加载共享库的程序实际上在启动时会花费更长的时间，因为必须要先找到共享库并将其加载到内存中。
- 由于目标模块没有被复制进可执行文件中，而是在共享库中集中维护的，因此在修改目标模块时无需重新链接程序就能够看到变更，甚至在运行着的程序正在使用共享库的现有版本的时候也能够进行这样的变更。

这项新增功能的主要开销如下所述。
- 在概念上以及创建共享库和构建使用共享库的程序的实践上，共享库比静态库更复杂。
- 共享库在编译时必须要使用`位置独立的代码`，这在大多数架构上都会带来性能开销，因为它需要使用额外的一个寄存器
- 在运行时必须要执行符号重定位。在符号重定位期间，需要将对共享库中每个符号（变量或函数）的引用修改成符号在虚拟内存中的实际运行时位置。由于存在这个重定位的过程，与静态链接程序相比，一个使用共享库的程序或多或少需要花费一些时间来执行这个过程。

> 共享库的另一种用法是作为 Java NativeInterface (JNI)中的一个构建块，它允许 Java 代码通过调用共享库中的 C 函数直接访问底层操作系统的特性
> 如果是静态库，可以把静态库转化成动态库

## 创建共享库
Executable and Linking Format（ELF）共享库 
```
$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
$ gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o
# 如下合并执行也可以
$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so
```
> 第一个命令创建了三个将要被放到库中的目标模块。
> cc –shared 命令创建了一个包含这三个目标模块的共享库。
> cc-fPIC 选项指定编译器应该生成位置独立的代码，这会改变编译器生成执行特定操作的代码的方式，包括访问全局、静态和外部变量，访问字符串常量，以及获取函数的地址。
> 这些变更使得代码可以在运行时被放置在任意一个虚拟地址处。

根据惯例，共享库的前缀为 lib，后缀为.so（表示 shared object）。

## 使用共享库

```
$ gcc -g -Wall -o prog prog.c libfoo.so
$ ./prog
./prog:error in loading shared libraries:libfoo.so:cannot open shared object file:No such file or directory
#修改后
$ LD_LIBRARY_PATH=. ./prog
```
> 执行时报错的原因是：`使用共享库运行时需要做动态链接`，来解析库名。动态连接器默认会在共享库的标准目录中寻找，很多共享库位于/lib和/usr/lib中。
> 如果需要指定其他目录，需要设置 LD_LIBRARY_PATH 环境变量

## 共享库 soname
使用别名来创建共享库，这种别名称为 soname（ELF 中的 DT_SONAME 标签）。
如果共享库拥有一个 soname，那么在`静态链接阶段会将soname 嵌入到可执行文件中，而
不会使用真实名称`，同时后面的动态链接器在运行时也会使用这个 soname 来搜索库。引入
soname 的目的是为了提供一层间接，使得可执行程序能够在运行时使用与链接时使用的库不
同的（但兼容的）共享库。

创建soname
```
$ gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o
$ gcc -g -Wall -o prog prog.c libfoo.so
$ LD_LIBRARY_PATH=. ./prog
prog:error in loading shared libraries:libbar.so:cannot open shared object file:No such file or directory
```
> 这里的问题是动态链接器无法找到名为 libbar.so 共享库。当使用 soname 时还需要做一件事情：
> 必须要创建一个符号链接将 soname 指向库的真实名称，并且必须要将这个符号链接放在动态链接器搜索的其中一个目录中。
> 因此可以像下面这样运行这个程序。

```
ln -s libfoo.so libbar.so
$ LD_LIBRARY_PATH=. ./prog
```

## 共享库工具
确定共享库的soname
objdump
readelf
显示程序所需的共享库
ldd


