进程组和会话在进程之间形成了一种两级层次关系：
进程组是一组相关进程的集合，会话是一组相关进程组的集合。

# 进程组

- 每个进程有个一个进程组id
- 新进程会继承父进程的进程组id
- 进程调用getpgrp系统调用可以获取进程id
- 如果调用getpgrp系统调用返回的进程id和自己的进程id相同，说明当前进程是这个进程组的首进程
- 每个进程组都会有一个首进程
- 首进程和其他进程的结束没有先后顺序
- 系统调用setpgid(pid,pgid) 可以将进程pid的进程组修改为 pgid，可以通过这个系统调用新建进程组

# 会话

- 会话是一个进程组的集合
- 新进程会继承父进程的会话id
- gettsid(pid)系统调用可以 可以返回指定进程的会话id；如果pid为0 ，会返回当前进程的会话id
- 如果gettsid(pid)=pid 说明pid进程为其所在会话的首进程
- 系统调用setsid() 会创建一个新会话；调用进程会成为新会话的首进程和该会话中新进程组的首进程；调用的进程没有控制终端，之前的`控制终端`会被断开

# 控制终端

- 一个会话所有的进程可能只拥有一个控制终端
- 一个终端只能至多成为一个会话的控制终端
- 当一个进程打开一个终端时，这个进程会成为该终端的控制进程
- 如果一个进程拥有控制终端，可以大概特殊的文件描述符 /dev/tty
- 删除进程与控制终端之间的关联或者控制进程终止时，内核会向`前台进程组`的所有成员发送sighup信号通知

# 前台后台进程组

- 一个会话中同一时刻只有一个进程成为前台进程，会话中其他所有进程都是后台进程
- 一个会话可以有多个后台进程组，但只能有一个前台进程组
- 前台进程组是唯一能自由读取和写入控制终端的进程组
- shell& 结尾可以转后台执行

# 作业
输入命令以`&`结束时，该命令会作为后台任务运行，如下
```
$ grep -r SIGHUP /usr/src/linux >x &
[1] 57475
$ sleep 60 &
[2] 57493
$ jobs
[1]  + running    sleep 60
TYPE CONTRO-Z
suspended  sleep 60
$ fg %1
$ bg %1
```
shell会为后台的每个进程赋一个唯一的作业号。当作业在后台运行之后以及在使用各种作业控制命令操作或监控作业时作业号会显示在方括号中。
作业号后面的数字是执行这个命令的进程的进程ID或管道中最后一个进程的进程ID。
在后面几个段落中介绍的命令中会使用%num来引用作业，其中num是shell赋给作业的作业号。

- shell会为后台的每个进程赋予一个唯一的作业号
- jobs命令可以查看所有的后台作业
- control-Z可以挂起作业，他会向终端的前台进程组发送sigtstp信号
- fg 后台转前台 ，同时可以恢复挂起的作业，并转前台
- bg 可以恢复挂起的作业，并转后台

`./job_mon | ./job_mon | ./job_mon `




# shell的sigup信号
SIGHUP(hong up) ，挂断。本信号在⽤户终端连接(正常或⾮正常)结束时发出, 通常是在终端的控制进程结束时, 通知同⼀session内的各个作业, 这时它们与控制终端不再关联。
登录Linux时，系统会分配给登录⽤户⼀个终端(Session)。在这个终端运⾏的所有程序，包括前台进程组和 后台进程组，⼀般都属于这个 Session。
当⽤户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。
这个信号的默认操作为终⽌进程，因此前台进 程组和后台有终端输出的进程就会中⽌。
不过可以捕获这个信号，⽐如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。
此外，对于与终端脱离关系的守护进程，这个信号⽤于通知它重新读取配置⽂件。

```
#输出会话id
echo $$ 
./catch_SIGHUP > samegroup.log 2 >&1 &
# 需要把terminal直接关闭 会发送sighup信号
./catch_SIGHUP x> samegroup.log 2 >&1
```

`exec ./disc_SIGHUP d s s > sig.log 2 >&1`
> exec命令时一个shell内置命令，它会导致shell执行一个exec()来使用指定的程序取代自己。
> 由于shell是终端的控制进程，因此现在这个程序已经成为了控制进程并且在终端窗口被关闭时会收到SIGHUP信号。
> 关闭终端窗口会导致SIGHUP信号被发送给控制进程（父进程），进而导致该进程的终止。
> 从上面可以看出，两个子进程与父进程位于同一个进程组中（终端的前台进程组），它们都收到了SIGHUP信号，但位于另一个进程组（后台）中的子进程并没有收到这个信号。


# 孤儿进程
每个成员的父进程本身是组的一个成员或不是组会话的一个成员 叫孤儿进程

