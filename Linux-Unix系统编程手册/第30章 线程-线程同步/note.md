主要介绍线程用来同步的两个工具：

- 互斥量（mutext）
- 条件变量（condition）

互斥量可以帮助线程同步对共享资源的使用，以防如下情况发生：线程某甲试图访问一共享变量时，线程某乙正在对其进行修改。条件变量则是在此之外的拾遗补缺，允许线程相互通知共享变量（或其他共享资源）的状态发生了变化。

# 互斥量

临界区：是指访问某一共享资源的代码块，并且这段代码的执行应该为原子操作（atomic);

当线程中引用全局变量时，会存一个全局变量的副本,叫自动变量（automatic variable）
这样如果多个线程共同操作同一共享变量，每个线程中都有存在一份副本
因为线程彼此之间是独立执行的，如果设置副本的值与把设置好的值赋值给共享变量的这一过程不是原子性的，会因为时间差而导致最终的结果不可预测

所以引出互斥量的概念，来保证在操作临界区代码块的原子性

## 静态分配互斥量

```c
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

s = pthread_mutex_lock(&mtx);
if (s != 0)
    errExitEN(s, "pthread_mutex_lock");

// TODO 临界区

s = pthread_mutex_unlock(&mtx);
if (s != 0)
    errExitEN(s, "pthread_mutex_unlock");
```

## 动态分配互斥量

```c
int pthread_mutex_init();
```

## 互斥量的性能

互斥量的实现采用了机器语言级的原子操作（在内存中执行，对多有线程可见），只有发生锁的竞争时才会执行系统调用

## 互斥量的死锁

互斥量 不能重入的原因导致 当超过一个线程加锁同一组互斥量时，就有可能发生死锁，自己等待自己。

## 死锁

两个线程 对资源的依赖顺序 正好相反，导致互相等待；
解决：对依赖资源的顺序 保持一致  或者 遇到竞争就释放已持有资源的锁

# 条件变量

考虑生产者消费者的场景，如果生产者生产了资源，消费者发现有未消费的资源就会做处理，如果没有条件变量，就需要 生产者线程一直不断的循环检查资源的变化情况，以做到有资源就可以立马消费

条件变量就是系统层面解决这一问题的
为什么条件变量都在临界区中处理？

1. 线程间传递信息，必须通过共享资源
2. 生产者消费者操作的是共享的资源
3. 为共享资源修改的最终一致性，共享资源必须获取互斥量

综上 所以 条件变量一定是在获取互斥量的前提下才能操作的
